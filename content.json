{"meta":{"title":"放不下的只是青春懵懂的执念","subtitle":"桜の花の落","description":null,"author":"Sakagami Tomoyo","url":""},"pages":[{"title":"番剧","date":"2019-02-10T13:32:48.000Z","updated":"2020-07-09T05:05:24.884Z","comments":true,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-07-14T11:11:29.210Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[桜の花の落Sakagami-Tomoyo] 与&nbsp; Sakagami-Tomoyo&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"categories","date":"2020-07-08T16:50:05.000Z","updated":"2020-07-08T17:04:16.897Z","comments":true,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-07-16T12:27:20.650Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友链"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-07-15T08:14:55.383Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2020-07-08T16:50:05.000Z","updated":"2020-07-08T16:53:12.886Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-07-09T11:51:28.155Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番剧列表 我的二次元世界，这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"}],"posts":[{"title":"Python学习笔记（二）：Numpy库（下）","slug":"numpy2","date":"2020-07-17T14:42:45.000Z","updated":"2020-07-21T13:51:22.407Z","comments":true,"path":"2020/07/17/numpy2/","link":"","permalink":"/2020/07/17/numpy2/","excerpt":"","text":"Python学习笔记（二）：Numpy库（上） 一、数组的变形1、修改数组的形状（1）、重塑重塑顾名思义就是将重新塑造数组的形状，即改变数组的维度。np.reshape函数和np.resize两个函数都可以实现这一点。 np.reshape在不改变数据的条件下修改形状，以下是它的定义： numpy.reshape(arr, newshape, order=’C’) 参数 说明 arr 要修改形状的数组 newshape 整数或者整数数组，新的形状应当兼容原有形状 order ‘C’ – 按行主序，’F’ – 按列主序，’A’ – 原顺序，’k’ – 元素在内存中的出现顺序。 例如下面将一维数组变为二维数组： import numpy as np x=np.arange(16) print(x) y = x.reshape(4,4) print(y) [ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15] [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15]] 当数组元素很多的时候或者该数组是高维数组时，当我们确定其他维的元素个数但是不想计算最后一个维度元素的个数，我们可以用-1来来取代。例如我把x重塑为(2,6)的形状，可以写作(2,-1)： y = x.reshape(2,-1) print(y) [[ 0 1 2 3 4 5 6 7] [ 8 9 10 11 12 13 14 15]] 针对于第三个参数的含义，我们先来看个例子： x=np.arange(12) print(x) y1 = x.reshape((4,3)) print(&quot;y1 = \\n{}&quot;.format(y1)) y2 = x.reshape((4,3),order = &#39;F&#39;) print(&quot;y2 = \\n{}&quot;.format(y2)) [ 0 1 2 3 4 5 6 7 8 9 10 11] y1 = [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]] y2 = [[ 0 4 8] [ 1 5 9] [ 2 6 10] [ 3 7 11]] 通过上面我们可以发现设定行为主序和列为主序两种情况得到的数组是不一样的。行主序指每行的元素在内存块中彼此相邻，而列主序指每列的元素在内存块中彼此相邻。在众多计算机语言中， 默认行主序的有 C 语言(下图 order=‘C’ 等价于行主序) 默认列主序的有 Fortran 语言(下图 order=‘F’ 等价于列主序) np.resize函数会返回指定形状的新数组，其定义如下： numpy.resize(arr, shape) 参数 说明 arr 要修改大小的数组 shape 返回数组的新形状 np.reshape函数与np.resize函数最大的区别就在于np.resize函数没有复制原数组（即完成操作后原数组改变），np.reshape函数复制了原数组（即完成操作后原数组不发生改变）。下面用代码验证一下： import numpy as np x=np.arange(16) print(x) y = x.reshape((4,4)) print(x) z = x.resize((4,4)) print(x) [ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15] [ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15] [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15]] （2）、打平打平数组顾名思义就是将多维数组变成一维数组。 np.ravel函数或np.flatten方法可以实现这一点。下面是这两个函数的定义： ndarray.flatten(order=’C’) numpy.ravel(a, order=’C’) 例如： a = np.arange(8).reshape(2,4) print(a) print(a.flatten()) print(np.ravel(a)) [[0 1 2 3] [4 5 6 7]] [0 1 2 3 4 5 6 7] [0 1 2 3 4 5 6 7] 这二者的区别是： np.flatten方法返回的是原数组的一个复制，修改数组元素不会改变原数组 np.ravel函数返回的是原数组的一个视图，修改数组元素会改变原数组 就拿上面的例子来说： b = a.flatten() b[0]=10 print(a) c = np.ravel(a) c[0]=10 print(a) [[0 1 2 3] [4 5 6 7]] [[10 1 2 3] [ 4 5 6 7]] 从结果我们可以看到当我们修改b数组的第一个元素值，a数组第一个元素值不改变。但是修改c数组第一个元素值a数组第一个元素值发生了改变。 2、翻转数组（1）转置在线性代数里面有矩阵的转置，在ndarray数组中也有相关的转置操作。其定义是：ndarray.T例如： a = np.arange(8).reshape(2,4) print(a) print(a.T) [[0 1 2 3] [4 5 6 7]] [[0 4] [1 5] [2 6] [3 7]] （2）对换数组的维度如果是多维数组中我想交换任意两个维度的顺序，或者将多个维度的顺序全部打乱，那么简单的转置并不能完成这一操作，这时候就要使用np.transpose方法，其定义如下： numpy.ndarray.transpose(axes) 参数 说明 axes 整数列表，列表中的数字顺序对应维度顺序 例如：现在有一个维度为(2,3,5)的数组，将数组的维度顺序变为2,3,1，即原来的第一维度变为第三维度，原来的第二维度变为第一维度，原来的第三维度变为第二维度： a = np.arange(30).reshape(2,3,5) print(&quot;原数组为：\\n{}&quot;.format(a)) print(&quot;改变后的数组为：\\n{}&quot;.format(a.transpose(1,2,0))) 原数组为： [[[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14]] [[15 16 17 18 19] [20 21 22 23 24] [25 26 27 28 29]]] 改变后的数组为： [[[ 0 15] [ 1 16] [ 2 17] [ 3 18] [ 4 19]] [[ 5 20] [ 6 21] [ 7 22] [ 8 23] [ 9 24]] [[10 25] [11 26] [12 27] [13 28] [14 29]]] 由于维度的改变，元素的坐标也发生改变。如果元素原来的坐标是(i,j,k)，那么现在的坐标为(j,k,i)。 （3）对换数组的两个维度如果我仅仅想对换数组的两个维度的顺序，那么就可以使用np.wapaxes函数，就不必设置所有维度的顺序了，其定义如下： numpy.swapaxes(arr, axis1, axis2) 参数 说明 arr 输入的数组 axis1 对应第一个轴的整数 axis2 对应第二个轴的整数 例如：我想交换维度为(2,3,5)的数组的第一和第二维度： a = np.arange(30).reshape(2,3,5) print(&quot;原数组为：\\n{}&quot;.format(a)) print(&quot;改变后的数组为：\\n{}&quot;.format(np.swapaxes(a,0,1))) 原数组为： [[[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14]] [[15 16 17 18 19] [20 21 22 23 24] [25 26 27 28 29]]] 改变后的数组为： [[[ 0 1 2 3 4] [15 16 17 18 19]] [[ 5 6 7 8 9] [20 21 22 23 24]] [[10 11 12 13 14] [25 26 27 28 29]]] 如果原来的元素坐标为(i,j,k)，那么变换后的坐标为(j,i,k)。 3、连接数组（1）np.concatenate函数np.concatenate函数可以说是通用的连接函数，因为它可以沿任意的现有轴进行连接数组。下面是其定义： numpy.concatenate((a1, a2, …), axis) 参数 说明 a1, a2, … 相同类型的数组 axis 沿着它连接数组的轴，默认为 0 例如下面分别对两个数组进行竖直方向（沿轴0）与水平方向（沿轴1）合并： a = np.array([[1,2],[3,4]]) b = np.array([[5,6],[7,8]]) print (&#39;a = \\n{}&#39;.format(a)) print (&#39;b = \\n{}&#39;.format(b)) print (&#39;沿轴 0 连接两个数组：&#39;) print (np.concatenate((a,b))) print (&#39;沿轴 1 连接两个数组：&#39;) print (np.concatenate((a,b),axis = 1)) a = [[1 2] [3 4]] b = [[5 6] [7 8]] 沿轴 0 连接两个数组： [[1 2] [3 4] [5 6] [7 8]] 沿轴 1 连接两个数组： [[1 2 5 6] [3 4 7 8]] （2）vstack, hstack, dstack函数通用的东西虽然好，但是效率不高，NumPy 里还有专门合并的函数： np.vstack：v 代表 vertical，竖直合并，等价于 concatenate(axis=0) np.hstack：h 代表 horizontal，水平合并，等价于 concatenate(axis=1) np.dstack：d 代表 depth-wise，按深度合并，可以理解为增加维度 下面是这三个函数的图示：下面用代码验证一下： print( np.vstack((a, b)) ) print( np.hstack((a, b)) ) print( np.dstack((a, b)) ) [[1 2] [3 4] [5 6] [7 8]] -------------- [[1 2 5 6] [3 4 7 8]] -------------- [[[1 5] [2 6]] [[3 7] [4 8]]] （3）r_, c_对象还有一种更简单的在竖直和水平方向合并的函数方法，使用np.r_和 np.c_对象。它们可以像vstack, hstack函数一样做简单的合并： a = np.array([1, 2, 3]) b = np.array([4, 5, 6]) c = np.c_[a,b] print(np.r_[a,b]) print(c) print(np.c_[c,a]) [1 2 3 4 5 6] ---------------- [[1 4] [2 5] [3 6]] ---------------- [[1 4 1] [2 5 2] [3 6 3]] 注意：np.r_和 np.c_的参数用[]括起来，不是()。因为np.r_和 np.c_本质上是将多个序列或数组合并成一个数组并返回，它们实际上是数组对象并不是函数。 如果np.r_和 np.c_仅有这个功能那么就完全和 vstack和hstack一样了就没有存在的必要了，所以下面介绍它们的特别用法： 1.参数可以是切片。 print( np.r_[-2:2:1, [0]*3, 5, 6] ) [-2 -1 0 1 0 0 0 5 6] 2.第一个参数可以是控制参数，如果它用 ‘r’ 或 ‘c’ 字符可生成线性代数最常用的矩阵 matrix (和二维 numpy array 稍微有些不同，在后面会详细介绍) a = np.r_[&#39;r&#39;, [1,2,3], [4,5,6]] print(a,type(a)) [[1 2 3 4 5 6]] &lt;class &#39;numpy.matrix&#39;&gt; 3.第一个参数可以是控制参数，如果它写成 ‘a,b,c’ 的形式，其中 a：代表轴，按「轴 a」来合并 b：合并后数组维度至少是 b c：在第 c 维上做维度提升 这么说可能有些抽象，那么用代码看一看具体的例子： print( np.r_[&#39;0,2,0&#39;, [1,2,3], [4,5,6]] ) print( np.r_[&#39;0,2,1&#39;, [1,2,3], [4,5,6]] ) print( np.r_[&#39;1,2,0&#39;, [1,2,3], [4,5,6]] ) print( np.r_[&#39;1,2,1&#39;, [1,2,3], [4,5,6]] ) print( np.r_[&#39;1,3,1&#39;, [1,2,3], [4,5,6]] ) [[1] [2] [3] [4] [5] [6]] ----------------- [[1 2 3] [4 5 6]] ----------------- [[1 4] [2 5] [3 6]] ------------------ [[1 2 3 4 5 6]] ------------------- [[[1] [2] [3] [4] [5] [6]]] 首先我们来看b参数的含义，通过上面的例子显而易见b参数决定了数组的维数，b = 2，那么最后得到的数组为二维数组。b = 3，那么最后得到的数组为三维数组。 然后我们再来看c参数，它的定义为：在第 c 维上做维度提升。如果b = 2,因为两个数组 [1,2,3], [4,5,6] 都是一维，所以： c = 0 代表在轴 0（列）上升一维，因此得到 [[1],[2],[3]] 和 [[4],[5],[6]] c = 1 代表在轴 1（行）上升一维，因此得到 [[1,2,3]] 和 [[4,5,6]] 如果b = 3： c = 0 代表在轴 0 上升两维，因此得到 [[[1]],[[2]],[[3]]] 和 [[[4]],[[5]],[[6]]] c = 1 代表在轴 1（列）上升两维，因此得到 [[[1],[2],[3]]] 和 [[[4],[5],[6]]] c = 2 代表在轴 2（行）上升两维，因此得到 [[[1,2,3]]] 和 [[[4,5,6]]] 最后我们来看参数a，以b = 2为例： a = 0, 沿着轴 0（列）合并 a = 1, 沿着轴 1（行）合并 下面是 b = 2 时的过程图： 4、分割数组（1）np.split函数和 concatenate() 函数一样，我们可以在 split() 函数里通过设定轴，来对数组沿着竖直方向分裂 (轴 0) 和沿着水平方向分裂 (轴 1)。下面是它的定义： numpy.split(ary, indices_or_sections, axis) 参数 说明 ary 被分割的数组 indices_or_sections 如果是一个整数，就用该数平均切分，如果是一个数组，为沿轴切分的位置 axis 沿着哪个维度进行切向，默认为0，横向切分。为1时，纵向切分 a = np.arange(9) print (&#39;第一个数组：&#39;) print (a) print (&#39;将数组分为三个大小相等的子数组：&#39;) b = np.split(a,3) print (b) print (&#39;将数组在一维数组中表明的位置分割：&#39;) b = np.split(a,[4,7]) print (b) 第一个数组： [0 1 2 3 4 5 6 7 8] 将数组分为三个大小相等的子数组： [array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8])] 将数组在一维数组中表明的位置分割： [array([0, 1, 2, 3]), array([4, 5, 6]), array([7, 8])] 其中第三步操作中的第二个参数 [4, 7] 相当于是个切片操作，将数组分成三部分： 第一部分 - 0:3 第二部分 - 4:6 第二部分 - 6:8 （2）np.hsplit, np.vsplit函数vsplit() 和 split(axis=0) 等价，hsplit() 和 split(axis=1) 等价。下面是图示：下面用代码展示一下np.hsplit函数： a = np.arange(25).reshape((5,5)) first, second, third = np.hsplit(a,[1,3]) print( &#39;第一个数组是：\\n{}&#39;.format(first) ) print( &#39;第二个数组是：\\n{}&#39;.format(second) ) print( &#39;第三个数组是：\\n{}&#39;.format(third) ) 第一个数组是： [[ 0] [ 5] [15] [20]] 第二个数组是： [[ 1 2] [ 6 7] [11 12] [16 17] [21 22]] 第三个数组是： [[ 3 4] [ 8 9] [13 14] [18 19] [23 24]] 5、添加和删除数组元素（1）添加添加数组元素主要有两个函数：np.append和np.insert函数。他们的区别是： np.append 函数在数组的末尾插入元素 np.insert 函数在某个特定位置之前插入元素 np.append 函数在数组的末尾添加值。 追加操作会分配整个数组，并把原来的数组复制到新数组中。此外，输入数组的维度必须匹配否则将生成ValueError。下面是函数定义： numpy.append(arr, values, axis=None) 参数 说明 arr 输入数组 values 要向arr添加的值，需要和arr形状相同（除了要添加的轴） axis 默认为 None。当axis无定义时，是横向加成，返回总是为一维数组！当axis有定义的时候，分别为0和1的时候。当axis有定义的时候，分别为0和1的时候（列数要相同）。当axis为1时，数组是加在右边（行数要相同）。 例如： a = np.array([[1,2,3],[4,5,6]]) print (&#39;第一个数组：&#39;) print (a) print (&#39;向数组添加元素：&#39;) print (np.append(a, [7,8,9])) print (&#39;沿轴 0 添加元素：&#39;) print (np.append(a, [[7,8,9]],axis = 0)) print (&#39;沿轴 1 添加元素：&#39;) print (np.append(a, [[5,5,5],[7,8,9]],axis = 1)) 第一个数组： [[1 2 3] [4 5 6]] 向数组添加元素： [1 2 3 4 5 6 7 8 9] 沿轴 0 添加元素： [[1 2 3] [4 5 6] [7 8 9]] 沿轴 1 添加元素： [[1 2 3 5 5 5] [4 5 6 7 8 9]] numpy.insert 函数在给定索引之前，沿给定轴在输入数组中插入值。如果值的类型转换为要插入，则它会广播（广播在下面数组的计算会详细说明）输入的值数组来匹配原数组进行插入。此外，如果未提供轴，则输入数组会被展开。下面是函数的定义： numpy.insert(arr, obj, values, axis) 参数 说明 arr 输入数组 obj 在其之前插入值的索引 values 要插入的值 axis 沿着它插入的轴，如果未提供，则输入数组会被展开 下面用代码实践一下： a = np.array([[1,2],[3,4],[5,6]]) print (&#39;第一个数组：&#39;) print (a) print (&#39;\\n&#39;) print (&#39;未传递 Axis 参数。 在插入之前输入数组会被展开。&#39;) print (np.insert(a,3,[11,12])) print (&#39;传递了 Axis 参数。 会广播值数组来配输入数组。&#39;) print (&#39;沿轴 0 广播：&#39;) print (np.insert(a,1,[11],axis = 0)) print (&#39;沿轴 1 广播：&#39;) print (np.insert(a,1,11,axis = 1)) 第一个数组： [[1 2] [3 4] [5 6]] 未传递 Axis 参数。 在插入之前输入数组会被展开。 [ 1 2 3 11 12 4 5 6] 传递了 Axis 参数。 会广播值数组来配输入数组。 沿轴 0 广播： [[ 1 2] [11 11] [ 3 4] [ 5 6]] 沿轴 1 广播： [[ 1 11 2] [ 3 11 4] [ 5 11 6]] （2）删除删除数组元素要用到np.delete函数。np.delete 函数返回从输入数组中删除指定子数组的新数组。 与 np.insert() 函数的情况一样，如果未提供轴参数，则输入数组将展开。下面是函数定义： numpy.delete(arr, obj, axis) 参数 说明 arr 输入数组 obj 可以被切片，整数或者整数数组，表明要从输入数组删除的子数组 axis 沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开 下面是具体例子： a = np.arange(12).reshape(3,4) print (&#39;第一个数组：&#39;) print (a) print (&#39;未传递 Axis 参数。 在插入之前输入数组会被展开。&#39;) print (np.delete(a,5)) print (&#39;删除第二列：&#39;) print (np.delete(a,1,axis = 1)) print (&#39;从数组中删除切片对应的元素：&#39;) a = np.array([1,2,3,4,5,6,7,8,9,10]) print (np.delete(a, np.s_[::2])) 第一个数组： [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] 未传递 Axis 参数。 在插入之前输入数组会被展开。 [ 0 1 2 3 4 6 7 8 9 10 11] 删除第二列： [[ 0 2 3] [ 4 6 7] [ 8 10 11]] 从数组中删除切片对应的元素： [ 2 4 6 8 10] 6、数组的复制数组的复制其实包括两种：重复 (repeat) 和拼接 (tile) 。 重复是在元素层面复制 拼接是在数组层面复制 np.repeat 方法复制的是数组的每一个元素，参数有几种设定方法： 一维数组：用标量和列表来复制元素的个数 多维数组：用标量和列表来复制元素的个数，用轴来控制复制的行和列 用具体例子来说明： a = np.arange(3) print( a ) print( a.repeat(3) ) print( a.repeat([2,3,4]) ) [0 1 2] [0 0 0 1 1 1 2 2 2] [0 0 1 1 1 2 2 2 2] 由上面的例子可以清晰地看到： 标量参数 3 表示数组 a 中每个元素复制 3 遍。 列表参数 [2,3,4] 表示数组 a 中每个元素分别复制 2, 3, 4 遍。 b = np.arange(6).reshape((2,3)) print( b ) print( b.repeat(2, axis=0) ) print( b.repeat([2,3,4], axis=1) ) [[0 1 2] [3 4 5]] [[0 1 2] [0 1 2] [3 4 5] [3 4 5]] [[0 0 1 1 1 2 2 2 2] [3 3 4 4 4 5 5 5 5]] 由上面的例子可以看到： 标量参数 2 和轴参数 0 表示数组b 中每个元素沿着轴 0 复制 2 遍。 列表参数 [2,3,4] 和轴 1表示数组 b 中每个元素沿着轴 1 分别复制 2, 3, 4 遍。 np.tile() 方法复制的是数组本身，参数有几种设定方法：标量：把数组当成一个元素，一列一列复制形状：把数组当成一个元素，按形状复制 a = np.arange(6).reshape((2,3)) print( a ) print( np.tile(a,2) ) print( np.tile(a, (2,3)) ) [[0 1 2] [3 4 5]] [[0 1 2 0 1 2] [3 4 5 3 4 5]] [[0 1 2 0 1 2 0 1 2] [3 4 5 3 4 5 3 4 5] [0 1 2 0 1 2 0 1 2] [3 4 5 3 4 5 3 4 5]] 由上面的例子可以清晰地看到： 标量参数 2 表示数组 a 按列复制 2 遍。 形状参数 (2,3) - 数组 a 按形状复制 6 (2×3) 遍，并以 (2,3) 的形式展现。 二、数组的计算1、元素层面的计算（1）一元运算一元运算包括倒数、平方、指数、对数、三角函数等等： a = np.array([[1., 2., 3.], [4., 5., 6.]]) print( 1 / a ) print( a ** 2 ) print( np.exp(a) ) print( np.log(a) ) [[1. 0.5 0.33333333] [0.25 0.2 0.16666667]] [[ 1. 4. 9.] [16. 25. 36.]] [[ 2.71828183 7.3890561 20.08553692] [ 54.59815003 148.4131591 403.42879349]] [[0. 0.69314718 1.09861229] [1.38629436 1.60943791 1.79175947]] （2）二元运算二元运算包括数组间的加减乘除： a = np.array([[1., 2., 3.], [4., 5., 6.]]) b = np.ones((2,3)) * 2 print( a + b + 1 ) print( a - b ) print( a * b ) print( a / b ) [[4. 5. 6.] [7. 8. 9.]] [[-1. 0. 1.] [ 2. 3. 4.]] [[ 2. 4. 6.] [ 8. 10. 12.]] [[0.5 1. 1.5] [2. 2.5 3. ]] （3）比较a = np.array([[1., 2., 3.], [4., 5., 6.]]) b = np.ones((2,3)) * 2 print(a &gt; b) print(a &gt; 3) [[False False True] [ True True True]] [[False False False] [ True True True]] 2、线性代数的计算因为运行速度的要求，通常会向量化 (vectorization) 而涉及大量的线性代数运算，尤其是矩阵之间的乘积运算。但是，在 NumPy 默认不采用矩阵运算，而是数组 (ndarray) 运算。矩阵只是二维，而数组可以是任何维度，因此数组运算更通用些。 下面我们分别对 数组 和 矩阵 从创建、转置、求逆和相乘四个方面看看它们的同异。 （1）创建创建数组 arr2d 和矩阵 A： arr2d = np.array([[1,2],[3,1]]) arr2d A = np.asmatrix(arr2d) A array([[1, 2], [3, 1]]) matrix([[1, 2], [3, 1]]) （2）转置数组用 arr2d.T 操作或 arr.tranpose() 方法，而矩阵用 A.T 操作。主要原因就是 .T 只适合二维数据，在上面也举了个三维数组三个轴之间的变换，这时就需要用函数 arr2d.tranpose 来实现了。 print( arr2d.T ) print( arr2d.transpose() ) print( A.T ) [[1 3] [2 1]] [[1 3] [2 1]] [[1 3] [2 1]] （3）求逆数组用 np.linalg.inv() 函数，而矩阵用 A.I 和 A**-1 操作： print( np.linalg.inv(arr2d) ) print( A.I ) print( A**-1 ) [[-0.2 0.4] [ 0.6 -0.2]] [[-0.2 0.4] [ 0.6 -0.2]] [[-0.2 0.4] [ 0.6 -0.2]] （4）相乘矩阵和数组的相乘是有区别的： 数组相乘是在元素层面进行， 矩阵相乘要就是数学定义的矩阵相乘 (比如第一个矩阵的列要和第二个矩阵的行一样) 首先看个例子，二维数组相乘一维数组，矩阵相乘向量我们先定义一个一维数组和向量： a = np.array([1,2]) b = np.asmatrix(a) print(a,type(a),a.shape) print(b,type(b),b.shape) [1 2] &lt;class &#39;numpy.ndarray&#39;&gt; (2,) [[1 2]] &lt;class &#39;numpy.matrix&#39;&gt; (1, 2) 通过结果我们可以看出 a 的形状是 (2,)，只含一个元素的元组只说明 arr 是一维，数组是不分行数组或列数组的。而 b 的形状是 (1,2)，显然是列向量。 数组和矩阵相乘都是用*： #array([[1, 2],[3, 1]]) #matrix([[1, 2],[3, 1]]) print( arr2d*arr ) print( A*b ) [[1 4] [3 2]] [[7 4]] 由上面结果可知： 二维数组相乘一维数组得到的还是个二维数组，解释它需要用到广播机制，这是下节的重点讨论内容。现在大概知道一维数组 [1 2] 第一个元素 1 乘上 [1 3] 得到 [1 3]，而第二个元素 2 乘上 [2 1] 得到 [4 2]。 而矩阵相乘向量的结果和我们学了很多年的线代结果很吻合。 再看一个例子，二维数组相乘二维数组，矩阵相乘矩阵： print( arr2d*arr2d ) print( A*A ) [[1 4] [9 1]] [[7 4] [6 7]] 由上面结果可以看出： 虽然两个二维数组相乘得到二维数组，但不是根据数学上矩阵相乘的规则得来的，而且由元素层面相乘得到的。两个 [[1 2], [3,1]] 的元素相乘确实等于 [[1 4], [9,1]]。 而矩阵相乘矩阵的结果和我们学了很多年的线代结果很吻合。 那么怎么才能在数组上实现「矩阵相乘向量」和「矩阵相乘矩阵」呢？用点乘函数np. dot()。 print( np.dot(arr2d,a) ) print( np.dot(arr2d,arr2d) ) [7 4] [[7 4] [6 7]] 结果对了，但还有一个小小的差异 矩阵相乘列向量的结果是个列向量，写成 [[7,4]]，形状是 (1,2) 二维数组点乘一维数组结果是个一维数组，写成 [7,4]，形状是 (2,) 3、元素整合计算在数组中，元素可以以不同方式整合 (aggregation)。拿求和 (sum) 函数来说，我们可以对数组 所有的元素求和 在某个轴 (axis) 上的元素求和 先定义数组 arr = np.arange(1,7).reshape((2,3)) arr array([[1, 2, 3], [4, 5, 6]]) 然后对于数组分别对全部元素、跨行 (across rows)、跨列 (across columns) 求和： arr = np.arange(1,7).reshape((2,3)) print( &quot;所有元素之和：&quot;, arr.sum() ) print( &quot;每一列上元素之和&quot;, arr.sum(axis=0) ) print( &#39;每一行上元素之和&#39;, arr.sum(axis=1) ) 所有元素之和： 21 每一列上元素之和 [5 7 9] 每一行上元素之和 [ 6 15] 除了 sum 函数，整合函数还包括 min, max, mean, std 和 cumsum，分别是求最小值、最大值、均值、标准差和累加，这些函数对数组里的元素整合方式和 sum 函数相同，就不多讲了。 4、广播机制的计算当对两个形状不同的数组按元素操作时，可能会触发「广播机制」。具体做法，先适当复制元素使得这两个数组形状相同后再按元素操作，两个步骤： 广播轴 (broadcast axis)：比对两个数组的维度，将形状小的数组的维度 (轴) 补齐 复制元素：顺着补齐的轴，将形状小的数组里的元素复制，使得最终形状和另一个数组吻合 先来看来例子： a = np.array([[0, 0, 0],[1, 1, 1],[2, 2, 2], [3, 3, 3]]) #arr1.shape = (4,3) b = np.array([1, 2, 3]) #arr2.shape = (3,) print(a + b) [[1 2 3] [2 3 4] [3 4 5] [4 5 6]] 上例中arr1的shape为（4,3），arr2的shape为（3，）。可以说前者是二维的，而后者是一维的。但是arr1的第二维长度为3，和arr2的维度相同。arr1和arr2的形状并不一样，但是它们可以执行相加操作，这就是通过广播完成的，在这个例子当中是将arr2沿着0轴进行扩展。上面程序当中的广播如下图所示： 因此，进行广播机制分两步： 检查两个数组形状是否兼容，即从两个形状元组最后一个元素，来检查： a. 它们是否有对应维度的相等子集 b. 是否有一个等于 1 一旦它们形状兼容，确定两个数组的最终形状。 触发广播机制一般有两种情况： （1）维度一样，形状不一样先举个例子： a = np.array([[1,2,3]]) b = np.array([[4],[5],[6]]) print( &#39;a的形状：&#39;, a.shape ) print( &#39;b的形状：&#39;, b.shape ) a的形状： (1, 3) b的形状： (3, 1) 回顾进行广播机制的两步： 检查数组 a 和 b 形状是否兼容，从两个形状元组 (1, 3) 和 (3, 1)最后一个元素开始检查，发现它们没有对应维度的相等子集，但它们都满足有一个等于 1的条件。 因此它们形状兼容，两个数组的最终形状为 (max(1,3), max(3,1)) = (3, 3) 让我们看看 a + b 等于多少： c = a + b print(&quot;c的形状：&quot;,c.shape) print(c) c的形状： (3, 3) [[5 6 7] [6 7 8] [7 8 9]] （2）维度不一样也先举个例子： a = np.array( [[[1,2,3], [4,5,6]]] ) b = np.arange(6).reshape((2,3)) print( &#39;a的形状：&#39;, a.shape ) print( &#39;b的形状：&#39;, b.shape ) a的形状： (1, 2, 3) b的形状： (2, 3) 回顾进行广播机制的两步： 检查数组 a 和 b 形状是否兼容，从两个形状元组 (1,2,3) 和 (2,3)最后一个元素开始检查，发现它们有对应维度的相等子集(2,3)，但是维度不同，这时可以让数组b缺失的维度用1补齐，则为(1,2,3)，与数组a的形状元组相同。 因此它们形状兼容，两个数组的最终形状为 (1,2,3) c = a + b print(&quot;c的形状：&quot;,c.shape) print(c) c的形状： (1, 2, 3) [[[ 1 3 5] [ 7 9 11]]] 三、参考 盘一盘 Python 系列 2 - NumPy NumPy 教程","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"数据分析","slug":"数据分析","permalink":"/tags/数据分析/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Python学习笔记（一）：Numpy库（上）","slug":"numpy","date":"2020-07-15T14:42:45.000Z","updated":"2020-07-17T10:02:35.829Z","comments":true,"path":"2020/07/15/numpy/","link":"","permalink":"/2020/07/15/numpy/","excerpt":"","text":"前言Numpy 是 Python 专门处理高维数组计算的包。直接pip install numpy进行安装，或者安装Anaconda，其中含有大量的机器学习和数据相关的Python模块。如果在安装或者学习过程中出现什么问题的话可以进入Numpy官网查看相关信息。在使用Numpy库之前首先我们要引用它： import numpy as np 因为每次使用Numpy中的方法或函数都要写numpy字数有点多，所以我们可以用np作为别名。 之所以要额外引入数组这一种数据结构在于它的计算效率非常高。下面是对数组和列表每个元素进行平方的运算速度对比： 先随机生成大小为10000000的数组和列表： Array = np.arange(10000000) List = list(range(10000000)) 然后分别对其中的每个元素进行平方处理： start1 = t.perf_counter() Array = Array ** 2 end1 = t.perf_counter() print(&quot;数组平方用时为{:4f}s&quot;.format(end1 - start1)) start2 = t.perf_counter() for i in List: i = i ** 2 end2 = t.perf_counter() print(&quot;列表平方用时为{:4f}s&quot;.format(end2 - start2)) 得到结果： 数组平方用时为0.021923s 列表平方用时为2.955364s 所以我们可以看出二者的运算速度相差了上百倍，所以numpy数组显然更适合做数值运算。 一、ndarray数组对象1、数组的初步认识NumPy 最重要的一个特点是其 n 维数组对象 ndarray，它是一系列同类型数据的集合所组成数据结构，以 0 下标为开始进行集合中元素的索引。ndarray 数组中的元素用的最多是数值型元素，平时我们说的一维、二维、三维数组长下面这个样子 (对应着线、面、体)。axis，中文叫轴，一个数组是多少维度就有多少根轴。 Python 计数都是从 0 开始的，如下图： 2、数组的创建（1）由python中的列表和元组等数据类型创建这种方法主要用到np.array()函数,参数里面是元组或者列表都可以： a = np.array([[2,3,4,7,5],[4,8,5,7,2]]) b = np.array(((1,2,5,3,7),(3,7,2,9,5))) print(&quot;a=\\n{}\\n&quot;.format(a)) print(&quot;b=\\n{}\\n&quot;.format(b)) a= [[2 3 4 7 5] [4 8 5 7 2]] b= [[1 2 5 3 7] [3 7 2 9 5]] 元组或列表混着来也可以: c = np.array([(1,3,7,5,2),[2,7,4,9,6]]) print(&quot;c=\\n{}\\n&quot;.format(c)) c= [[1 3 7 5 2] [2 7 4 9 6]] （2）定隔定点创建这种创建方式一共有两种函数： np.arange()：固定元素大小间隔 np.linspace()：固定元素个数 np.arange()函数的定义如下： numpy.arange(start, stop, step, dtype) 参数说明： 参数 说明 start 起始值，默认为0 stop 终止值（不能为空且不包括） step 步长，默认为1 dtype 返回ndarray的数据类型，如果没有提供，则会使用输入数据的类型。 下面是具体例子： d1 = np.arange(5) d2 = np.arange(2,5) d3 = np.arange(2,8,2) print(&quot;d1=\\n{}\\n&quot;.format(d1)) print(&quot;d2=\\n{}\\n&quot;.format(d2)) print(&quot;d3=\\n{}\\n&quot;.format(d3)) d1= [0 1 2 3 4] d2= [2 3 4] d3= [2 4 6 8] np.linspace()函数的定义如下： np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None) 参数说明： 参数 说明 start 序列的起始值 stop 序列的终止值，如果endpoint为true，该值包含于数列中 num 要生成的等步长的样本数量，默认为50 endpoint 该值为 true 时，数列中包含stop值，反之不包含，默认是True。 retstep 如果为 True 时，生成的数组中会显示间距，反之不显示。 dtype 返回ndarray的数据类型，如果没有提供，则会使用输入数据的类型。 下面是具体例子： d4 = np.linspace(1,100,8) d5 = np.linspace(1,100,8,endpoint=False) print(&quot;d4=\\n{}\\n&quot;.format(d4)) print(&quot;d5=\\n{}\\n&quot;.format(d5)) d4= [ 1. 15.14285714 29.28571429 43.42857143 57.57142857 71.71428571 85.85714286 100. ] d5= [ 1. 13.375 25.75 38.125 50.5 62.875 75.25 87.625] （3）特殊数组创建这种创建方式有以下这些函数： ones()函数生成元素全为1的多维数组，参数为元组类型 zeros()函数生成元素全为0的多维数组，参数为元组类型 full()函数根据第一个参数生成一个多维数组，元素全为第二个参数 eye()函数生成一个n维的单位矩阵，参数为n ones_like()函数根据参数中的数组形状生成一个全为1的数组 zeros_like()函数根据参数中的数组形状生成一个全为0的数组 full_like()函数根据第一个参数数组的形状生成一个全为第二个参数的数组 下面是具体例子： e = np.ones((2,2,5)) f = np.zeros((2,5)) g = np.full((2,5),8) h = np.eye((3)) # a=[[2 3 4 7 5][4 8 5 7 2]] i = np.ones_like(a) j = np.zeros_like(a) k = np.full_like(a,8) print(&quot;e=\\n{}\\n&quot;.format(e)) print(&quot;f=\\n{}\\n&quot;.format(f)) print(&quot;g=\\n{}\\n&quot;.format(g)) print(&quot;h=\\n{}\\n&quot;.format(h)) print(&quot;i=\\n{}\\n&quot;.format(i)) print(&quot;j=\\n{}\\n&quot;.format(j)) print(&quot;k=\\n{}\\n&quot;.format(k)) e= [[[1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.]] [[1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.]]] f= [[0. 0. 0. 0. 0.] [0. 0. 0. 0. 0.]] g= [[8 8 8 8 8] [8 8 8 8 8]] h= [[1. 0. 0.] [0. 1. 0.] [0. 0. 1.]] i= [[1 1 1 1 1] [1 1 1 1 1]] j= [[0 0 0 0 0] [0 0 0 0 0]] k= [[8 8 8 8 8] [8 8 8 8 8]] 3、数组的属性下表展示了数组的一些常见的属性： 属性 含义 naim 表示数组的秩，即数组的维数 shape 表示数组是几行几列的 size 表示数组元素的个数 dtype 表示数组的元素类型 itemsize 数组中每个元素的大小，以字节为单位 下面是具体的例子 # a=[[2 3 4 7 5][4 8 5 7 2]] print(a.ndim) print(a.shape) print(a.size) print(a.dtype) print(a.itemsize) 2 (2, 5) 10 int32 4 其中下面列表中列举了常用的的数组的元素类型： 名称 描述 简写 np.bool 用一个字节存储的布尔类型（True或False） ‘b’ np.int8 一个字节大小，-128 至 127 ‘i’ np.int16 整数，-32768 至 32767 ‘i2’ np.int32 整数，-232 至 232 -1 ‘i4’ np.int64 整数，-264 至 264 - 1 ‘i8’ np.uint8 无符号整数，0 至 255 ‘u’ np.uint16 无符号整数，0 至 65535 ‘u2’ np.uint32 无符号整数，0 至 232 - 1 ‘u4’ np.uint64 无符号整数，0 至 264 - 1 ‘u8’ np.float16 半精度浮点数：16位，正负号1位，指数5位，精度10位 ‘f2’ np.float32 单精度浮点数：32位，正负号1位，指数8位，精度23位 ‘f4’ np.float64 双精度浮点数：64位，正负号1位，指数11位，精度52位 ‘f8’ np.complex64 复数，分别用两个32位浮点数表示实部和虚部 ‘c8’ np.complex128 复数，分别用两个64位浮点数表示实部和虚部 ‘c16’ np.object_ python对象 ‘O’ np.string_ 字符串 ‘S’ np.unicode_ unicode类型 ‘U’ 二、数组的存储与读入1、CSV文件格式CSV文件的存储和读入只适用于一维和二维数组 （1）存储将数组储存为CSV格式的函数如下： np.savetxt(frame, array, fmt=&#39;%.18e&#39;, delimiter=None) 参数 说明 frame 存储的文件名（也可以是字符串，产生器，压缩文件） array 存入文件的数组 fmt 数组元素写入文件的格式，例如：%d %.2f %.18e delimiter 分割字符串，默认是任何空格，如果是CSV文件，则使用’,’它可以生成任意带有分割符的文件 例如： a = np.arange(60).reshape(5,12) print(&#39;a=\\n{}\\n&#39;.format(a)) np.savetxt(&#39;a.csv&#39;,a,fmt=&#39;%d&#39;,delimiter=&#39;,&#39;) a= [[ 0 1 2 3 4 5 6 7 8 9 10 11] [12 13 14 15 16 17 18 19 20 21 22 23] [24 25 26 27 28 29 30 31 32 33 34 35] [36 37 38 39 40 41 42 43 44 45 46 47] [48 49 50 51 52 53 54 55 56 57 58 59]] 下图是用Excel打开a.csv文件： （2）读入将CSV格式的数组文件读入的函数如下： np.loadtxt(frame, dtype=np.float, delimiter=None, skiprows=0, usecols=None, unpack=False) 参数 说明 frame 存储的文件名（也可以是字符串，产生器，压缩文件） dtype 需要将文件的数据转化为特定格式，由dtype指定 delimiter 分割字符串，默认是任何空格，如果是CSV文件，则使用’,’ skipprows 读取文件时需要跳过的行数，默认为0 usecols 选取指定的列，默认为全部 unpack 如果是True，把每一列当成一个向量输出写入不同变量（默认为False） 例如我要读取a.csv文件且不要第一行： b = np.loadtxt(&#39;a.csv&#39;,dtype=np.int,delimiter=&#39;,&#39;skiprows=1) print(&#39;b=\\n{}\\n&#39;.format(b)) b= [[12 13 14 15 16 17 18 19 20 21 22 23] [24 25 26 27 28 29 30 31 32 33 34 35] [36 37 38 39 40 41 42 43 44 45 46 47] [48 49 50 51 52 53 54 55 56 57 58 59]] 结果数组b与数组a相一致。而如果我要选取两列分别赋给两个变量的话，就要通过usecols和unpack变量，下面是把文件中数组的第一列： b,c = np.loadtxt(&#39;a.csv&#39;,dtype=np.int,delimiter=&#39;,&#39;,usecols=(0, 2),unpack=True) b= [ 0 12 24 36 48] c= [ 2 14 26 38 50] 2、其他格式由于CSV文件的存储和读入只适用于一维和二维数组，所以当遇见多维数组或者不想储存为CSV格式时我们可以使用tofile()方法与fromfile()函数存储和读入数组。 （1）存储数组的储存我们可以使用tofile()方法，其定义为： a.tofile(frame,sep=&#39;&#39;,format=&#39;%s&#39;) 参数 说明 frame 存储的文件名（也可以是字符串，产生器，压缩文件） sep 设置分隔符（默认为空串，如果为空串文件将用二进制方式储存） format 数组元素写入文件的格式 例如： c = np.arange(100).reshape(2,5,10) print(&#39;c=\\n{}\\n&#39;.format(c)) c.tofile(&#39;c.txt&#39;,sep=&#39;,&#39;,format=&#39;%d&#39;) c= [[[ 0 1 2 3 4 5 6 7 8 9] [10 11 12 13 14 15 16 17 18 19] [20 21 22 23 24 25 26 27 28 29] [30 31 32 33 34 35 36 37 38 39] [40 41 42 43 44 45 46 47 48 49]] [[50 51 52 53 54 55 56 57 58 59] [60 61 62 63 64 65 66 67 68 69] [70 71 72 73 74 75 76 77 78 79] [80 81 82 83 84 85 86 87 88 89] [90 91 92 93 94 95 96 97 98 99]]] 下图是用记事本打开c.txt文件：从图中我们可以看出，数组通过tofile()方法储存在文件中的形式是一维数组，并不是它本来的形状。所以我们通常还需要建立一个维度信息文件用来储存维度信息方便读入。 如果我们采用二进制形式存储（二进制形式可以压缩文件大小）： c.tofile(&#39;c1.txt&#39;,format=&#39;%d&#39;) #二进制形式的存储和读入 用记事本打开c1.txt文件，文件中都是乱码： （2）读入将数组文件读入可以使用fromfile()函数，它的定义为： np.fromfile(frame,dtype=float,count=-1,sep=&#39;&#39;) 参数 说明 frame 存储的文件名（也可以是字符串，产生器，压缩文件） dtype 文件的数据类型（默认为浮点数） count 设置读取数据的个数（默认为-1，表示全部读入） sep 设置分隔符（默认为空串，如果为空串文件将用二进制方式读入） 例如： d = np.fromfile(&#39;c.txt&#39;,dtype=np.int,count=-1,sep=&#39;,&#39;).reshape(2,5,10) print(&#39;d=\\n{}\\n&#39;.format(d)) d= [[[ 0 1 2 3 4 5 6 7 8 9] [10 11 12 13 14 15 16 17 18 19] [20 21 22 23 24 25 26 27 28 29] [30 31 32 33 34 35 36 37 38 39] [40 41 42 43 44 45 46 47 48 49]] [[50 51 52 53 54 55 56 57 58 59] [60 61 62 63 64 65 66 67 68 69] [70 71 72 73 74 75 76 77 78 79] [80 81 82 83 84 85 86 87 88 89] [90 91 92 93 94 95 96 97 98 99]]] 如果是读取二进制文件，如c1.txt： d = np.fromfile(&#39;c1.txt&#39;,dtype=np.int).reshape(2,5,10) print(&#39;d=\\n{}\\n&#39;.format(d)) d= [[[ 0 1 2 3 4 5 6 7 8 9] [10 11 12 13 14 15 16 17 18 19] [20 21 22 23 24 25 26 27 28 29] [30 31 32 33 34 35 36 37 38 39] [40 41 42 43 44 45 46 47 48 49]] [[50 51 52 53 54 55 56 57 58 59] [60 61 62 63 64 65 66 67 68 69] [70 71 72 73 74 75 76 77 78 79] [80 81 82 83 84 85 86 87 88 89] [90 91 92 93 94 95 96 97 98 99]]] 从上面我们可以发现得到的两个d数组都与c数组一致。 3、.npy格式Numpy本身有它自己的.npy文件格式，使用np.save()函数和np.load()函数存储和读入。 （1）存储使用np.save()函数对数组进行存储，下面是其定义：np.save(fname,array) 参数 说明 frame 文件名，扩展名为.npy，压缩文件的扩展名为.npz array 存入文件的数组 例如： np.save(&#39;c.npy&#39;,c) np.save()函数其实是用二进制形式存储，且把维度信息存储下来。如果用记事本打开c.npy文件，可以发现里面是乱码：通过与c1.txt文件对比我们可以发现二者之间的差别就是c.npy文件第一行多了维度信息。正是因为这一点所以使用np.save()函数储存多维数组时不用额外建立一个文件储存维度信息。 （2）读入.npy或者.npz文件的读入使用np.load()函数，其定义如下： np.load(fname) 参数 说明 frame 文件名，扩展名为.npy，压缩文件的扩展名为.npz 例如： d = np.load(&#39;c.npy&#39;) print(&#39;d=\\n{}\\n&#39;.format(d)) d= [[[ 0 1 2 3 4 5 6 7 8 9] [10 11 12 13 14 15 16 17 18 19] [20 21 22 23 24 25 26 27 28 29] [30 31 32 33 34 35 36 37 38 39] [40 41 42 43 44 45 46 47 48 49]] [[50 51 52 53 54 55 56 57 58 59] [60 61 62 63 64 65 66 67 68 69] [70 71 72 73 74 75 76 77 78 79] [80 81 82 83 84 85 86 87 88 89] [90 91 92 93 94 95 96 97 98 99]]] 三、数组的索引和切片1、类似Python基础语法的索引和切片（1）一维数组一维数组的索引和切片和列表类似 m = np.array([1,13.375,25.75,38.125,50.5,62.875,75.25,87.625]) print(&quot;m=\\n{}\\n&quot;.format(m)) print(&quot;m数组的第3个元素是：{}\\n&quot;.format(m[2])) print(&quot;m数组从第2到第7个元素偶数序号的元素是：{}\\n&quot;.format(m[1:6:2])) m= [ 1. 13.375 25.75 38.125 50.5 62.875 75.25 87.625] m数组的第3个元素是：25.75 m数组从第2到第7个元素偶数序号的元素是：[13.375 38.125 62.875] （2）二维数组二维数组的索引把每个维度的序号都写出来，维度序号之间用逗号分割，二维数组的切片和Matlab类似，维度之间用逗号隔开，每个维度的切片和一维数组一样。其他多维数组也是一样。 p = np.arange(24).reshape((2,3,4)) print(&quot;p=\\n{}\\n&quot;.format(p)) print(&quot;p数组第一维度的第1个元素的第2行第3个元素是：{}\\n&quot;.format(p[0,1,2])) print(&quot;p数组第一维度的第2个元素的第3行的所有元素是：{}\\n&quot;.format(p[1,2])) print(&quot;p数组第一维度的最后1个元素的倒数第二行的所有元素是：{}\\n&quot;.format(p[-1,-2])) print(&quot;p数组偶数列的所有元素是：\\n{}\\n&quot;.format(p[:,:,1::2])) p= [[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] [[12 13 14 15] [16 17 18 19] [20 21 22 23]]] p数组第一维度的第1个元素的第2行第3个元素是：6 p数组第一维度的第2个元素的第3行的所有元素是：[20 21 22 23] p数组第一维度的最后1个元素的倒数第二行的所有元素是：[16 17 18 19] p数组偶数列的所有元素是： [[[ 1 3] [ 5 7] [ 9 11]] [[13 15] [17 19] [21 23]]] （3）切片与索引区别在这里我们要注意：虽然切片可以看作是多次索引，但二者还是有区别的： 切片得到的是原数组的一个视图，修改切片中的内容会改变原数组 索引得到的是原数组的一个复制，修改索引中的内容不会改变原数组 比如：如果是修改索引中的内容，像如果我将通过索引得到数组a的第1行第3个元素值的变量的值修改为10，但是a数组本身并不会改变： # a = [[2,3,4,7,5],[4,8,5,7,2]] x = a[0,2] x = 10 print(a) [[2 3 4 7 5] [4 8 5 7 2]] 但是如果修改切片中的内容，像我将通过切片得到数组a的第一行第2到第4元素的变量y的第2个值变为10（也就是数组a的第1行第3个元素值），那么修改之后数组a会发生变化： y = a[0,1:4] y[1] = 10 print(a) [[ 2 3 10 7 5] [ 4 8 5 7 2]] 2、整数数组索引Numpy中不仅仅像Python序列中一样只能用整数来索引，还可以用整数数组来索引。 （1）设定行和列中不同的索引先来看个例子： print(a[[0,1],[0,4]]) [2 2] 这里得到的结果并不是数组a通过整数索引：[0,1],[0,4]对应的第1行第2和第5个元素3，5。而是数组a通过整数索引：[0,0],[1,4]对应的第1行第1个元素和第2行第5个元素2，2。 这里我们可以把第n个数组当作是被索引的元素的第n根轴（axis n-1）上对应位置的集合。 比如上面例子中的两个元素分别位于第1和第2行，所以第一个数组为[0,1]。而它们在各自行上分别是处于第1列和第5列，所以第2个数组为[0,4]。 下面再举一个例子：通过整数数组索引得到 4X3 数组中的位于四个角的元素。 x = np.array([[0,1,2],[3,4,5],[6,7,8],[9,10,11]]) print (&quot;x = \\n{}&quot;.format(x)) y = x[[0,0,-1,-1],[0,-1,0,-1]] print(&quot;数组x的四个角的元素是：{}&quot;.format(y)) x = [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]] 数组x的四个角的元素是：[ 0 2 9 11] （2）按特定顺序获取特定元素通过上面介绍的整数数组的索引方法我们可以按特定顺序获取特定元素：例如我想按照4，1，2的顺序获取数组第1，2，4行： print(x[[3,0,1]]) [[ 9 10 11] [ 0 1 2] [ 3 4 5]] （3）选取方形区域的索引（借助np.ix_函数）np.ix_函数就是输入两个数组，产生笛卡尔积的映射关系。例如： x=np.arange(32).reshape((8,4)) print (&quot;x = \\n{}\\n&quot;.format(x)) print (x[np.ix_([1,5,7,2],[0,3,1,2])]) x = [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19] [20 21 22 23] [24 25 26 27] [28 29 30 31]] [[ 4 7 5 6] [20 23 21 22] [28 31 29 30] [ 8 11 9 10]] np.ix_函数将输入的数组[1,5,7,2]和数组[0,3,1,2]产生笛卡尔积，就是得到(1,0)，(1,3)，(1,1)，(1,2)；(5,0)，(5,3)，(5,1)，(5,2)；(7,0)，(7,3)，(7,1)，(7,2)；(2,0)，(2,3)，(2,1)，(2,2)。然后将这些位置构成一个数组进行索引。 3、布尔索引布尔索引，就是用一个由布尔类型值组成的数组来选择元素的方法。看下面的例子：我要从数组x中选出大于5的元素 # x = [[0,1,2],[3,4,5],[6,7,8],[9,10,11]] print (&quot;x = \\n{}\\n&quot;.format(x)) y = x&gt;5 print(y) x = [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]] [[False False False] [False False False] [ True True True] [ True True True]] 像上面例子中所示，如果直接将选择条件打印出来得到的是一个值为 True 和 False 的布尔数组。而这个布尔数组可以作为一个索引。对应位置是 True 则输出，False 则跳过： z = x[y] print(z) [ 6 7 8 9 10 11] 当然也可以直接print(x[x&gt;5]),上面的写法只是为了突出布尔数组。 四、参考 盘一盘 Python 系列 2 - NumPy NumPy 教程 MOOC课程Python数据分析与展示","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"数据分析","slug":"数据分析","permalink":"/tags/数据分析/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Win10上搭建Hexo+Github个人博客","slug":"hexo-github","date":"2020-07-13T14:56:01.000Z","updated":"2020-07-17T07:27:34.342Z","comments":true,"path":"2020/07/13/hexo-github/","link":"","permalink":"/2020/07/13/hexo-github/","excerpt":"","text":"一、前言 博主一直以来在学习过程中总是会出现学了就忘，记忆不深等问题。所以为了改善这一问题，就萌生了搭建自己的博客来记录自己的学习过程、笔记与心得的想法。 作为一个小白，在实际的搭建过程中博主参阅了很多的视频或者图文教程，很多教程都很杂且不完整。所以接下来就给大家带来自己搭建的过程记录和其他比较好的教程。 二、大概流程 （1）安装配置Git工具 （2）安装配置Node.js （3）安装Hexo （4）生成博客 （5）将博客部署到Github 三、具体步骤Step 1：安装配置Git工具（1）下载安装Git进入Git官网下载Win10对应的版本，如下图选择对应的版本安装。下载完成之后安装时不用管其他的配置问题，一路按照提示一直next即可。如果不放心的话可以点击这里，这篇博文介绍了安装过程中出现的各种选项的具体含义，可以根据自己的个人实际需要来选择。 安装完成之后在菜单中看见以下三样东西就表示安装成功。 （2）创建和配置Github进行配置Github之前我们要有自己的Github账户，如果没有Github账户，进入Github官网，注册一个新账户，一定要记住自己的用户名、密码和电子邮箱。 当我们有了Github账户，登陆Github，进入下图界面后点击右上方的加号，然后点击New repository创建新仓库。当我们跳转到如下创建仓库页面之后，先输入仓库名。注意！！仓库名格式：Github用户名.github.io，（这里博主是已经建立了这个仓库所以显示已经存在，正常的话会有绿色的对勾）。然后接下来的描述随便写什么都行，然后就可以点击创建仓库了。如果可以如下图一样进入仓库代表创建成功，Github配置完成。 （3）配置Git配置Git实际上是连接Git和Github，在菜单栏打开Git Bash，设置user.name和user.email配置信息： 在命令行中输入以下代码： git config --global user.name &quot;你的GitHub用户名&quot; git config --global user.email &quot;你的GitHub注册邮箱&quot; 在这之后生成密钥SSH key，在命令行中输入以下代码： ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 例如我输入的信息如下： 执行了生成密钥命令会提示存储路径和密码以及确认密码，可以不用管，直接按三次enter，然后就OK了，但不要关闭Git Bash。 最后再将生成的SSH key添加到Github上。首先找到密钥的文件，文件的路径在生成密钥的命令行中，如下：然后打开这个路径，打开下图所指的文件（我是用VScode打开的），复制其中的内容：然后进入你的github主页点击右上角头像，点击setting -&gt; SSH and GPG keys，或者点击这里，新建密钥SSH key。然后在Git Bash上执行下面的代码： ssh -T git@github.com 输入之后，会出现以下提示： The authenticity of host &#39;github.com (52.74.223.119)&#39; can&#39;t be established. RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no)? 输入yes后，如果出现以下提示，代表配置成功！ Hi Sakagami-Tomoyo! You&#39;ve successfully authenticated, but GitHub does not provide shell access. Step 2：安装配置Node.js进入Node.js官网，下载安装包：下载完之后安装时不用管其他选项，一路按照提示点next就行。安装完成之后打开命令提示符（win+R -&gt; 输入cmd -&gt; enter）输入指令node -v、npm -v，查看node和npm版本信息，如果出现对应的版本号则环境变量设置成功。如下图： Step 3：安装Hexo打开Git Bash，输入如下代码安装淘宝的cnpm管理器（时间可能有点长，也有可能会安装失败，但是不用担心，重新输入代码安装就行） npm install -g cnpm --registry=http://registry.npm.taobao.org 由于我之前安装过，所以出现的提示可能不一样，但是只要出现类似的提示就代表安装成功。安装成功之后，继续在Git Bash上输入cnpm -v查看cnpm版本，如果出现对应版本信息，也说明安装成功。这些工作完成之后正式安装Hexo，在Git Bash上输入以下代码： cnpm install -g hexo-cli 之后在输入hexo -v查看Hexo信息，出现以下信息代表安装成功： Step4：生成博客首先在本地创建blog文件夹，随便哪里都行，这里我放在了D盘：点击进入blog文件夹，进入后右击鼠标点击Git Bash here，输入： hexo init 生成博客（可能有点慢），生成完毕后，输入： hexo s 如下图：然后在浏览器打开http://localhost:4000，如果出现如下图所示界面代表博客生成成功！ Step5：将博客部署到Github首先在blog目录下安装git部署插件。在blog目录下的Git Bash中输入： cnpm install --save hexo-deployer-git 安装完成后，打开自己的Github，进入到刚才新创建的仓库中，然后复制自己的仓库的地址（点击绿色的code按钮就会出现以下这个界面）：然后打开blog目录下的配置文件_config.yml（我是用VScode打开的）：在配置文件中找到如下代码： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: 将它们改成： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: https://github.com/YourGithubName/YourGithubName.github.io.git branch: master 注意！每一行冒号（英文冒号）后面都有空格，repo后面的地址是刚才复制的仓库地址，粘贴上去就可以（上面是我的仓库地址） 改正之后，保存文件并关闭，然后将改变部署到Github仓库里。在blog目录下的Git Bash中输入： hexo d 可能在运行过程中会弹出下面的窗口：输入自己的Github用户名后，之后还会弹出一个窗口输入自己的Github密码就可以了。输入后有下图类似的提示就代表部署成功。之后你就可以直接用https://你的Github用户名.github.io/（比如我自己的https://sakagami-tomoyo.github.io/）访问自己的博客了！至此Hexo+Github个人博客的搭建完成！ 四、参考CodeSheep大佬的B站教学视频（可以看看，上面的步骤大部分都是按照视频上来的，只不过是基于MacOS搭建的）","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"/tags/Hexo/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}